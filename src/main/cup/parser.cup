package org.ifn660.jflexer;

import java_cup.runtime.*;
import org.ifn660.jflexer.ast.*;
import java.util.ArrayList;
import java.util.List;



/* Symbol lists
These declarations name and supply an object type for each terminal and non-terminal symbol that appears in the grammar
Terminals are returned by the scanner and placed on the parse stack
Non-terminals replace a series of Symbol objects on the parse stack when the RHS of a production is recognised
*/

parser code 
{:
	public Node root;
:}

terminal        INT, BOOLEAN, CHAR, CONST, DOUBLE, FLOAT, LONG, SHORT;
terminal        CLASS, SUPER, INTERFACE, EXTENDS, IMPLEMENTS;
terminal        String VOID;// vthai: Terminal needs a type as well  //vthai:If we are using a terminal's value inside the CUP action, remember we need to add it in the scanner first
terminal        NULL;
terminal        IF, ELSE, DO, WHILE, FOR, CASE, SWITCH, BREAK;
terminal        RETURN;
terminal        String PUBLIC, PRIVATE, PROTECTED, ABSTRACT, STRICTFP, FINAL, STATIC;
terminal        ASSERT, BYTE;
terminal        CONTINUE, DEFAULT, ENUM, FINALLY, GOTO;
terminal        IMPORT, INSTANCEOF, NATIVE, NEW, PACKAGE;
terminal        SYNCHRONIZED, THIS, TRANSIENT, VOLATILE;
terminal        CATCH, TRY, THROW, THROWS;
terminal        String IDENTIFIER;
terminal        OP_EQ, OP_GT, OP_LT, OP_NOT_EQ, OP_UNARY, OP_TERNARY, OP_LOOP_IN, OP_LAMBDA, 
                OP_EQ_EQ, OP_GT_EQ, OP_LT_EQ, OP_LOGIC_AND, OP_LOGIC_OR, OP_POS_INCR, 
                OP_NEG_INCR, OP_PLUS, OP_MINUS, OP_MULTIPLY, OP_DIVIDE, OP_AND, OP_OR, OP_XOR, 
                OP_MODULUS, OP_BIT_L_SHIFT, OP_BIT_R_SHIFT, OP_UNSIGN_R_SHIFT, OP_ADD_AND, OP_MINUS_AND, 
                OP_MULTIPLY_AND, OP_DIVIDE_AND, OP_BIT_AND, OP_BIT_INCL_OR, OP_BIT_EXCL_OR, 
                OP_MODULUS_AND, OP_L_SHIFT_AND, OP_R_SHIFT_AND, OP_UNSIGN_R_SHIFT_AND;
terminal        INTEGER_LITERAL, STRING_LITERAL;
terminal        LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON, COMMA, DOT;
terminal        UNKNOWN;

nonterminal      Node CompilationUnit, TypeDeclaration_opt, TypeDeclaration, ClassDeclaration;
nonterminal      Node NormalClassDeclaration;
nonterminal      ClassBody ClassBody, ClassBodyDeclaration, ClassBodyDeclaration_opt;
nonterminal      List<String> ClassModifier_opt;// vthai: Non terminal needs to be declare with a correct AST class type!
nonterminal      Type Result;
nonterminal      String ClassModifier;
nonterminal      FormalParameter, UnannType, UnannReferenceType;
nonterminal      VariableDeclaratorList, VariableDeclarator_opt, VariableDeclarator;
nonterminal      VariableDeclaratorId, VariableInitializer_opt, VariableInitializer;
nonterminal      UnannArrayType, UnannClassOrInterfaceType, UnannClassType, Dims_opt, Dims;
nonterminal      MethodDeclaration MethodDeclaration, ClassMemberDeclaration;
nonterminal      List<String> MethodModifier_opt;
nonterminal      String MethodModifier;
nonterminal      Node[] MethodHeader;
nonterminal      MethodBody, MethodDeclarator, FormalParameterList_opt, FormalParameterList, FormalParameters;
nonterminal      Block, BlockStatements_opt, BlockStatements, BlockStatement_opt, BlockStatement;
nonterminal      LocalVariableDeclarationStatement, LocalVariableDeclaration;
nonterminal      UnnanType, UnnanPrimitiveType, UnnanReferenceType, NumericType, IntegralType, FloatingPointType;
nonterminal      String Identifier;
nonterminal      LastFormalParameter;
nonterminal      Literal;
nonterminal      PrimaryNoNewArray, Primary, PostfixExpression, UnaryExpressionNotPlusMinus;
nonterminal      UnaryExpression, MultiplicativeExpression, AdditiveExpression, ShiftExpression;
nonterminal      RelationalExpression, EqualityExpression, AndExpression, ExclusiveOrExpression;
nonterminal      InclusiveOrExpression, ConditionalAndExpression, ConditionalOrExpression;
nonterminal      ConditionalExpression, AssignmentExpression, Expression;
nonterminal      PackageDelcaration_opt, PackageDelcaration, ImportDeclaration_opt, ImportDeclaration;
nonterminal      TypeParameters_opt, TypeParameters, Superclass_opt, Superclass, Superinterfaces_opt, Superinterfaces;
nonterminal      Throws_opt, Throws, VariableModifier_opt, VariableModifier, TypeArguments_opt, TypeArguments;
nonterminal      PreIncrementExpression, PreDecrementExpression;
nonterminal      ExpressionName, PostIncrementExpression, PostDecrementExpression, ArrayCreationExpression;
nonterminal		 CastExpression, AmbiguousName;

/* Compilation related grammar */

CompilationUnit             ::= PackageDelcaration_opt ImportDeclaration_opt TypeDeclaration_opt;

PackageDelcaration_opt      ::= PackageDelcaration
                            | /* empty */
                            ;

ImportDeclaration_opt       ::= ImportDeclaration_opt ImportDeclaration
                            | /* empty */
                            ;

TypeDeclaration_opt         ::= TypeDeclaration_opt TypeDeclaration 
                            | /* empty */
                            ;

TypeDeclaration             ::= ClassDeclaration;

ClassDeclaration            ::= NormalClassDeclaration;



NormalClassDeclaration      ::= ClassModifier_opt:cmdOpt CLASS Identifier:i TypeParameters_opt Superclass_opt Superinterfaces_opt ClassBody:cb
							{:
								RESULT = new ClassDeclaration(i, cmdOpt, cb);//zyx :for the identifier. It is  a non termianl so here we new one class to pass the value from scanner to the class we built. 
//zyx: because this is the top of the AST.so ths can only get the name of the tree structure for the befinning part.
//like hte identifier is nontermial there no value here; the deviation tree built here will  drive to the bottom which is 
//zyx : Identifier::= IDENTIFIER. here is terminal. so the scanner will pass the a value called IDENTIFIER to there .and the cup will catch this value pass to the i, THEN i pass to RESULT, THEN give to the up laver  which is here .and this value will  pass to i here the nwe use i as class parameter to pass to a class we built before.(the valus passed here is "Example")
//zyx : the top is the value pass prosure. it seems we need all the sequence to pass the value to the top. THEN that is possible to let the coresponding node to get the value
//zyx : but before get value we need to pass the value to the top throgh that tree.looks long 
//zyx:but the place we need to creat class instance is just the place in the AST.which is the class hierarchyu we creat.
//zyx:by the way if I want to use the terminal I need to state in the Jflexe.and give the correspinding type. 
//zyx : for the nonterminal we need to git the type as well. 
								parser.root = (Node)RESULT;
							:};

TypeParameters_opt           ::= TypeParameters
                            | /* empty */
                            ;
                               
Superclass_opt              ::= Superclass
                            | /* empty */
                            ;
                               
Superinterfaces_opt          ::= Superinterfaces
                            | /* empty */
                            ;

ClassModifier_opt           ::= ClassModifier_opt :cmdOpt ClassModifier:cm 
                            {: 
                                if (cmdOpt == null) {
                                    cmdOpt = new ArrayList<>();
                                }
                                RESULT = cmdOpt;
                                RESULT.add(new String(cm)); 
                            :}
                            | /* empty */
                            ;
                            //vthai: This should be the common template for doing a recursive capture, unless somebody find a better way
                            // zyx : this is the way to realize the options 

ClassModifier               ::= PUBLIC:p {: RESULT = p; :} | PROTECTED:p {: RESULT = p; :} | PRIVATE:p {: RESULT = p; :} | ABSTRACT:p {: RESULT = p; :} | STATIC:s {: RESULT = (String)s; :} | FINAL:p {: RESULT = p; :} | STRICTFP:p {: RESULT = p; :};

ClassBody                   ::= LBRACE ClassBodyDeclaration_opt:cbOpt {: RESULT = cbOpt; :} RBRACE;//zyx: there no corresponding class here so just pass the value from the bottom.
//zyx : here should be one clss here .but not ,it just get from the bottom. here is a option which means have a lot options .

Identifier                  ::= IDENTIFIER:i {: RESULT = i; :};//zyx : this whole struture is just bulit for the termianl from scanner , this is the first termail we get from sanner, here add one RESULT=i; "i" is a kind of sign for the termianl and nonterminal.'

ClassBodyDeclaration_opt    ::= ClassBodyDeclaration_opt ClassBodyDeclaration:cb //zyx:zyx: there no corresponding class here so just pass the value from the bottom.
                            {: 
                                RESULT = cb;
                            :}
                            | /* empty */
                            ;

ClassBodyDeclaration        ::= ClassMemberDeclaration:cmd {: RESULT = new ClassBody(cmd); :};// zyx : here new one class which means the ClassBodyDeclaration is hte classbody type

ClassMemberDeclaration      ::= MethodDeclaration:md {: RESULT = md; :};

/* Method related grammar */

MethodDeclaration           ::= MethodModifier_opt:mmOpt MethodHeader:mh MethodBody:MethodBody
                            {: 
                                RESULT = new MethodDeclaration(mmOpt, (Result)mh[0], null, null, null);
                            :};

MethodModifier_opt          ::= MethodModifier_opt:mmOpt MethodModifier:mm
                            {:
                                if (mmOpt == null) {
                                    mmOpt = new ArrayList<>();
                                }
                                RESULT = mmOpt;
                                RESULT.add(mm);
                            :}
                            | /* empty */
                            ;

MethodModifier              ::= PUBLIC:p {: RESULT = p; :} | PROTECTED:p {: RESULT = p; :} | PRIVATE:p {: RESULT = p; :} | ABSTRACT:p {: RESULT = p; :} | STATIC:p {: RESULT = p; :} | FINAL:p {: RESULT = p; :} | STRICTFP:p {: RESULT = p; :};

MethodHeader                ::= Result:i MethodDeclarator:md Throws_opt
                            {:
                                RESULT = new Node[2];
                                RESULT[0] = new Result(i);
                                RESULT[1] = null; /* TODO expand in the future */
                            :};

Throws_opt                  ::= Throws
                            | /* empty */
                            ;

Result                      ::= VOID:v {: RESULT = new NamedType(v); :};

MethodDeclarator            ::= Identifier LPAREN FormalParameterList_opt RPAREN;

FormalParameterList_opt     ::= FormalParameterList
                            | /* empty */
                            ;

FormalParameterList         ::= LastFormalParameter;

LastFormalParameter         ::= FormalParameter;

FormalParameter             ::= VariableModifier_opt UnannType VariableDeclaratorId;

VariableModifier_opt        ::= VariableModifier_opt VariableModifier
                            | /* empty */
                            ;

UnannType                   ::= UnannReferenceType;

UnannReferenceType          ::= UnannArrayType;

UnannArrayType              ::= UnannClassOrInterfaceType Dims;

Dims                        ::= LBRACK RBRACK;

UnannClassOrInterfaceType   ::= UnannClassType;

UnannClassType              ::= Identifier TypeArguments_opt
                            ;

TypeArguments_opt           ::= TypeArguments
                            | /* empty */
                            ;

/* Assignment Expression related grammar */

Expression                  ::= AssignmentExpression;

AssignmentExpression        ::= ConditionalExpression;

ConditionalExpression       ::= ConditionalOrExpression
                            | ConditionalOrExpression OP_TERNARY Expression OP_LOOP_IN ConditionalExpression;

ConditionalOrExpression     ::= ConditionalAndExpression;

ConditionalAndExpression    ::= InclusiveOrExpression;

InclusiveOrExpression       ::= ExclusiveOrExpression;

ExclusiveOrExpression       ::= AndExpression
							| ExclusiveOrExpression OP_XOR AndExpression
							;

AndExpression               ::= EqualityExpression
                            | AndExpression OP_LOGIC_AND EqualityExpression;

EqualityExpression          ::= RelationalExpression
                            | EqualityExpression OP_EQ_EQ RelationalExpression
                            | EqualityExpression OP_NOT_EQ RelationalExpression;

RelationalExpression        ::= ShiftExpression;

ShiftExpression             ::= AdditiveExpression
                            | ShiftExpression OP_BIT_L_SHIFT AdditiveExpression
                            | ShiftExpression OP_BIT_R_SHIFT AdditiveExpression
                            | ShiftExpression OP_UNSIGN_R_SHIFT AdditiveExpression;

AdditiveExpression          ::= MultiplicativeExpression
							| AdditiveExpression OP_PLUS MultiplicativeExpression
							| AdditiveExpression OP_MINUS MultiplicativeExpression
							;

MultiplicativeExpression    ::= UnaryExpression
                            |MultiplicativeExpression OP_MULTIPLY UnaryExpression
                            |MultiplicativeExpression OP_DIVIDE UnaryExpression
                            |MultiplicativeExpression OP_MODULUS UnaryExpression;

UnaryExpression             ::= PreIncrementExpression
                            | PreDecrementExpression
                            | OP_PLUS UnaryExpression
                            | OP_MINUS UnaryExpression
                            | UnaryExpressionNotPlusMinus;

UnaryExpressionNotPlusMinus ::= PostfixExpression
							| OP_UNARY UnaryExpression
							| OP_NOT_EQ UnaryExpression
							| CastExpression;

PostfixExpression           ::= Primary
                            | ExpressionName
                            | PostIncrementExpression
                            | PostDecrementExpression
                            ;

Primary                     ::= PrimaryNoNewArray
                            | ArrayCreationExpression
                            ;
                            
ExpressionName              ::= Identifier
                            | AmbiguousName DOT Identifier
                            ;
                            
AmbiguousName               ::= Identifier
                            | AmbiguousName DOT Identifier
                            ;

PrimaryNoNewArray           ::= Literal;

Literal                     ::= INTEGER_LITERAL;

/* Method body related grammar */

MethodBody                  ::= Block
                            ;

Block                       ::= LBRACE BlockStatements_opt RBRACE
                            ;

BlockStatements_opt         ::= BlockStatements
                            | /* empty */
                            ;

BlockStatements             ::= BlockStatement BlockStatement_opt
                            ;

BlockStatement_opt          ::= BlockStatement_opt BlockStatement
                            | /* empty */
                            ;

BlockStatement              ::= LocalVariableDeclarationStatement
                            ;

LocalVariableDeclarationStatement ::= LocalVariableDeclaration SEMICOLON
                                   ;

LocalVariableDeclaration    ::= VariableModifier_opt UnnanType VariableDeclaratorList
                            ;

VariableDeclaratorList      ::= VariableDeclarator VariableDeclarator_opt;
                            
VariableDeclarator_opt      ::= COMMA VariableDeclarator_opt VariableDeclarator
                            | /* empty */
                            ;
                            
VariableDeclarator          ::= VariableDeclaratorId VariableInitializer_opt
                            ;

VariableInitializer_opt     ::= OP_EQ VariableInitializer
                            | /* empty */
                            ;
                            
VariableDeclaratorId        ::= Identifier Dims_opt
                            ;

Dims_opt                    ::= Dims
                            | /* empty */
                            ;

VariableInitializer         ::= Expression;

UnnanType                   ::= UnnanPrimitiveType
                            /*| UnnanReferenceType*/
                            ;

UnnanPrimitiveType          ::= NumericType
                            /*| BOOLEAN*/
                            ;

NumericType                 ::= IntegralType
                            | FloatingPointType
                            ;

IntegralType                ::= INT
                            | CHAR
                            | BYTE
                            | SHORT
                            | LONG
                            ;

FloatingPointType           ::= DOUBLE
                            | FLOAT
                            ;

